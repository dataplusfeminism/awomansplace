import {
  rt
} from "./chunk-6Z7PEVYP.js";
import {
  derived,
  writable
} from "./chunk-UTIALTTK.js";
import {
  get_store_value
} from "./chunk-DCE4O3CF.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-V6TY7KAL.js";

// node_modules/@sveltekit-i18n/base/dist/index.js
var H = Object.defineProperty;
var q = Object.defineProperties;
var B = Object.getOwnPropertyDescriptors;
var x = Object.getOwnPropertySymbols;
var K = Object.prototype.hasOwnProperty;
var A = Object.prototype.propertyIsEnumerable;
var N = (s2, t2, e) => t2 in s2 ? H(s2, t2, { enumerable: true, configurable: true, writable: true, value: e }) : s2[t2] = e;
var l = (s2, t2) => {
  for (var e in t2 || (t2 = {})) K.call(t2, e) && N(s2, e, t2[e]);
  if (x) for (var e of x(t2)) A.call(t2, e) && N(s2, e, t2[e]);
  return s2;
};
var f = (s2, t2) => q(s2, B(t2));
var L = (s2, t2) => {
  var e = {};
  for (var a in s2) K.call(s2, a) && t2.indexOf(a) < 0 && (e[a] = s2[a]);
  if (s2 != null && x) for (var a of x(s2)) t2.indexOf(a) < 0 && A.call(s2, a) && (e[a] = s2[a]);
  return e;
};
var C = ["error", "warn", "debug"];
var $ = ({ logger: s2 = console, level: t2 = C[1], prefix: e = "[i18n]: " }) => C.reduce((a, r, i2) => f(l({}, a), { [r]: (o) => C.indexOf(t2) >= i2 && s2[r](`${e}${o}`) }), {});
var c = $({});
var V = (s2) => {
  c = s2;
};
var z = (n2) => {
  var d2 = n2, { parser: s2, key: t2, params: e, translations: a, locale: r, fallbackLocale: i2 } = d2, o = L(d2, ["parser", "key", "params", "translations", "locale", "fallbackLocale"]);
  if (!t2) return c.warn(`No translation key provided ('${r}' locale). Skipping translation...`), "";
  if (!r) return c.warn(`No locale provided for '${t2}' key. Skipping translation...`), "";
  let u2 = (a[r] || {})[t2];
  if (i2 && u2 === void 0 && (c.debug(`No translation provided for '${t2}' key in locale '${r}'. Trying fallback '${i2}'`), u2 = (a[i2] || {})[t2]), u2 === void 0) {
    if (c.debug(`No translation provided for '${t2}' key in fallback '${i2}'.`), o.hasOwnProperty("fallbackValue")) return o.fallbackValue;
    c.warn(`No translation nor fallback found for '${t2}' .`);
  }
  return s2.parse(u2, e, r, t2);
};
var h = (...s2) => s2.length ? s2.filter((t2) => !!t2).map((t2) => {
  let e = `${t2}`.toLowerCase();
  try {
    let [a] = Intl.Collator.supportedLocalesOf(t2);
    if (!a) throw new Error();
    e = a;
  } catch (a) {
    c.warn(`'${t2}' locale is non-standard.`);
  }
  return e;
}) : [];
var w = (s2, t2, e) => {
  if (t2 && Array.isArray(s2)) return s2.map((a) => w(a, t2));
  if (s2 && typeof s2 == "object") {
    let a = Object.keys(s2).reduce((r, i2) => {
      let o = s2[i2], n2 = e ? `${e}.${i2}` : `${i2}`;
      return o && typeof o == "object" && !(t2 && Array.isArray(o)) ? l(l({}, r), w(o, t2, n2)) : f(l({}, r), { [n2]: w(o, t2) });
    }, {});
    return Object.keys(a).length ? a : null;
  }
  return s2;
};
var G = (s2) => s2.reduce((t2, { key: e, data: a, locale: r }) => {
  if (!a) return t2;
  let [i2] = h(r), o = f(l({}, t2[i2] || {}), { [e]: a });
  return f(l({}, t2), { [i2]: o });
}, {});
var E = async (s2) => {
  try {
    let t2 = await Promise.all(s2.map((r) => {
      var i2 = r, { loader: e } = i2, a = L(i2, ["loader"]);
      return new Promise(async (o) => {
        let n2;
        try {
          n2 = await e();
        } catch (d2) {
          c.error(`Failed to load translation. Verify your '${a.locale}' > '${a.key}' Loader.`), c.error(d2);
        }
        o(f(l({ loader: e }, a), { data: n2 }));
      });
    }));
    return G(t2);
  } catch (t2) {
    c.error(t2);
  }
  return {};
};
var W = (s2) => (t2) => {
  try {
    if (typeof t2 == "string") return t2 === s2;
    if (typeof t2 == "object") return t2.test(s2);
  } catch (e) {
    c.error("Invalid route config!");
  }
  return false;
};
var F = (s2, t2) => {
  let e = true;
  try {
    e = Object.keys(s2).filter((a) => s2[a] !== void 0).every((a) => s2[a] === t2[a]);
  } catch (a) {
  }
  return e;
};
var D = 1e3 * 60 * 60 * 24;
var O = class {
  constructor(t2) {
    this.cachedAt = 0;
    this.loadedKeys = {};
    this.currentRoute = writable();
    this.config = writable();
    this.isLoading = writable(false);
    this.promises = /* @__PURE__ */ new Set();
    this.loading = { subscribe: this.isLoading.subscribe, toPromise: (t3, e) => {
      let { fallbackLocale: a } = get_store_value(this.config), r = Array.from(this.promises).filter((i2) => {
        let o = F({ locale: h(t3)[0], route: e }, i2);
        return a && (o = o || F({ locale: h(a)[0], route: e }, i2)), o;
      }).map(({ promise: i2 }) => i2);
      return Promise.all(r);
    }, get: () => get_store_value(this.isLoading) };
    this.privateRawTranslations = writable({});
    this.rawTranslations = { subscribe: this.privateRawTranslations.subscribe, get: () => get_store_value(this.rawTranslations) };
    this.privateTranslations = writable({});
    this.translations = { subscribe: this.privateTranslations.subscribe, get: () => get_store_value(this.translations) };
    this.locales = f(l({}, derived([this.config, this.privateTranslations], ([t3, e]) => {
      if (!t3) return [];
      let { loaders: a = [] } = t3, r = a.map(({ locale: o }) => o), i2 = Object.keys(e).map((o) => o);
      return Array.from(/* @__PURE__ */ new Set([...h(...r), ...h(...i2)]));
    }, [])), { get: () => get_store_value(this.locales) });
    this.internalLocale = writable();
    this.loaderTrigger = derived([this.internalLocale, this.currentRoute], ([t3, e], a) => {
      var r, i2;
      t3 !== void 0 && e !== void 0 && !(t3 === ((r = get_store_value(this.loaderTrigger)) == null ? void 0 : r[0]) && e === ((i2 = get_store_value(this.loaderTrigger)) == null ? void 0 : i2[1])) && (c.debug("Triggering translation load..."), a([t3, e]));
    }, []);
    this.localeHelper = writable();
    this.locale = { subscribe: this.localeHelper.subscribe, forceSet: this.localeHelper.set, set: this.internalLocale.set, update: this.internalLocale.update, get: () => get_store_value(this.locale) };
    this.initialized = derived([this.locale, this.currentRoute, this.privateTranslations], ([t3, e, a], r) => {
      get_store_value(this.initialized) || r(t3 !== void 0 && e !== void 0 && !!Object.keys(a).length);
    });
    this.translation = derived([this.privateTranslations, this.locale, this.isLoading], ([t3, e, a], r) => {
      let i2 = t3[e];
      i2 && Object.keys(i2).length && !a && r(i2);
    }, {});
    this.t = f(l({}, derived([this.config, this.translation], (r) => {
      var [i2] = r, o = i2, { parser: t3, fallbackLocale: e } = o, a = L(o, ["parser", "fallbackLocale"]);
      return (n2, ...d2) => z(l({ parser: t3, key: n2, params: d2, translations: this.translations.get(), locale: this.locale.get(), fallbackLocale: e }, a.hasOwnProperty("fallbackValue") ? { fallbackValue: a.fallbackValue } : {}));
    })), { get: (t3, ...e) => get_store_value(this.t)(t3, ...e) });
    this.l = f(l({}, derived([this.config, this.translations], (i2) => {
      var [o, ...n2] = i2, d2 = o, { parser: t3, fallbackLocale: e } = d2, a = L(d2, ["parser", "fallbackLocale"]), [r] = n2;
      return (u2, b, ...k) => z(l({ parser: t3, key: b, params: k, translations: r, locale: u2, fallbackLocale: e }, a.hasOwnProperty("fallbackValue") ? { fallbackValue: a.fallbackValue } : {}));
    })), { get: (t3, e, ...a) => get_store_value(this.l)(t3, e, ...a) });
    this.getLocale = (t3) => {
      let { fallbackLocale: e } = get_store_value(this.config) || {}, a = t3 || e;
      if (!a) return;
      let r = this.locales.get();
      return r.find((o) => h(a).includes(o)) || r.find((o) => h(e).includes(o));
    };
    this.setLocale = (t3) => {
      if (t3 && t3 !== get_store_value(this.internalLocale)) return c.debug(`Setting '${t3}' locale.`), this.internalLocale.set(t3), this.loading.toPromise(t3, get_store_value(this.currentRoute));
    };
    this.setRoute = (t3) => {
      if (t3 !== get_store_value(this.currentRoute)) {
        c.debug(`Setting '${t3}' route.`), this.currentRoute.set(t3);
        let e = get_store_value(this.internalLocale);
        return this.loading.toPromise(e, t3);
      }
    };
    this.loadConfig = async (t3) => {
      await this.configLoader(t3);
    };
    this.getTranslationProps = async (t3 = this.locale.get(), e = get_store_value(this.currentRoute)) => {
      let a = get_store_value(this.config);
      if (!a || !t3) return [];
      let r = this.translations.get(), { loaders: i2, fallbackLocale: o = "", cache: n2 = D } = a || {}, d2 = Number.isNaN(+n2) ? D : +n2;
      this.cachedAt ? Date.now() > d2 + this.cachedAt && (c.debug("Refreshing cache."), this.loadedKeys = {}, this.cachedAt = 0) : (c.debug("Setting cache timestamp."), this.cachedAt = Date.now());
      let [u2, b] = h(t3, o), k = r[u2], I = r[b], R = (i2 || []).map((j) => {
        var T = j, { locale: p2 } = T, y = L(T, ["locale"]);
        return f(l({}, y), { locale: h(p2)[0] });
      }).filter(({ routes: p2 }) => !p2 || (p2 || []).some(W(e))).filter(({ key: p2, locale: y }) => y === u2 && (!k || !(this.loadedKeys[u2] || []).includes(p2)) || o && y === b && (!I || !(this.loadedKeys[b] || []).includes(p2)));
      if (R.length) {
        this.isLoading.set(true), c.debug("Fetching translations...");
        let p2 = await E(R);
        this.isLoading.set(false);
        let y = Object.keys(p2).reduce((T, P2) => f(l({}, T), { [P2]: Object.keys(p2[P2]) }), {}), j = R.filter(({ key: T, locale: P2 }) => (y[P2] || []).some((S) => `${S}`.startsWith(T))).reduce((T, { key: P2, locale: S }) => f(l({}, T), { [S]: [...T[S] || [], P2] }), {});
        return [p2, j];
      }
      return [];
    };
    this.addTranslations = (t3, e) => {
      if (!t3) return;
      let a = get_store_value(this.config), { preprocess: r } = a || {};
      c.debug("Adding translations...");
      let i2 = Object.keys(t3 || {});
      this.privateRawTranslations.update((o) => i2.reduce((n2, d2) => f(l({}, n2), { [d2]: l(l({}, n2[d2] || {}), t3[d2]) }), o)), this.privateTranslations.update((o) => i2.reduce((n2, d2) => {
        let u2 = true, b = t3[d2];
        return typeof r == "function" && (b = r(b)), (typeof r == "function" || r === "none") && (u2 = false), f(l({}, n2), { [d2]: l(l({}, n2[d2] || {}), u2 ? w(b, r === "preserveArrays") : b) });
      }, o)), i2.forEach((o) => {
        let n2 = Object.keys(t3[o]).map((d2) => `${d2}`.split(".")[0]);
        e && (n2 = e[o]), this.loadedKeys[o] = Array.from(/* @__PURE__ */ new Set([...this.loadedKeys[o] || [], ...n2 || []]));
      });
    };
    this.loader = async ([t3, e]) => {
      let a = this.getLocale(t3) || void 0;
      c.debug(`Adding loader promise for '${a}' locale and '${e}' route.`);
      let r = (async () => {
        let i2 = await this.getTranslationProps(a, e);
        i2.length && this.addTranslations(...i2);
      })();
      this.promises.add({ locale: a, route: e, promise: r }), r.then(() => {
        a && this.locale.get() !== a && this.locale.forceSet(a);
      });
    };
    this.loadTranslations = (t3, e = get_store_value(this.currentRoute) || "") => {
      let a = this.getLocale(t3);
      if (a) return this.setRoute(e), this.setLocale(a), this.loading.toPromise(a, e);
    };
    this.loaderTrigger.subscribe(this.loader), this.isLoading.subscribe(async (e) => {
      e && this.promises.size && (await this.loading.toPromise(), this.promises.clear(), c.debug("Loader promises have been purged."));
    }), t2 && this.loadConfig(t2);
  }
  async configLoader(t2) {
    if (!t2) return c.error("No config provided!");
    let n2 = t2, { initLocale: e, fallbackLocale: a, translations: r, log: i2 } = n2, o = L(n2, ["initLocale", "fallbackLocale", "translations", "log"]);
    i2 && V($(i2)), [e] = h(e), [a] = h(a), c.debug("Setting config."), this.config.set(l({ initLocale: e, fallbackLocale: a, translations: r }, o)), r && this.addTranslations(r), e && await this.loadTranslations(e);
  }
};

// node_modules/sveltekit-i18n/dist/index.js
var n = Object.defineProperty;
var M = Object.defineProperties;
var u = Object.getOwnPropertyDescriptors;
var s = Object.getOwnPropertySymbols;
var f2 = Object.prototype.hasOwnProperty;
var P = Object.prototype.propertyIsEnumerable;
var i = (r, o, e) => o in r ? n(r, o, { enumerable: true, configurable: true, writable: true, value: e }) : r[o] = e;
var p = (r, o) => {
  for (var e in o || (o = {})) f2.call(o, e) && i(r, e, o[e]);
  if (s) for (var e of s(o)) P.call(o, e) && i(r, e, o[e]);
  return r;
};
var d = (r, o) => M(r, u(o));
var l2 = (r, o) => {
  var e = {};
  for (var a in r) f2.call(r, a) && o.indexOf(a) < 0 && (e[a] = r[a]);
  if (r != null && s) for (var a of s(r)) o.indexOf(a) < 0 && P.call(r, a) && (e[a] = r[a]);
  return e;
};
var m = (e) => {
  var a = e, { parserOptions: r = {} } = a, o = l2(a, ["parserOptions"]);
  return d(p({}, o), { parser: rt(r) });
};
var t = class extends O {
  constructor(e) {
    super(e && m(e));
    this.loadConfig = (e2) => super.configLoader(m(e2));
  }
};
var D2 = t;
export {
  D2 as default
};
//# sourceMappingURL=sveltekit-i18n.js.map
